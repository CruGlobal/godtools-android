import groovy.json.JsonOutput
import groovy.json.JsonSlurper

apply plugin: 'de.undercouch.download'

android.libraryVariants.all { variant ->
    def mobileContentApi = variant.flavorName.contains("stage") ? uris.mobileContentApi.stage : uris.mobileContentApi.production

    // include the list of downloaded tools and languages as a BuildConfig constant
    variant.buildConfigField('java.util.List<String>', 'BUNDLED_TOOLS', 'java.util.Arrays.asList('
            + bundledContent.tools.collect{ "\"$it\"" }.join(',') + ')')
    variant.buildConfigField('java.util.List<String>', 'BUNDLED_LANGUAGES', 'java.util.Arrays.asList('
            + bundledContent.languages.collect{ "\"$it\"" }.join(',') + ')')

    // create a generated assets directory for the initial content and add it to the most specific source set available.
    def assetGenDir = new File(project.buildDir, "generated/assets/initial-content/" + variant.dirName)
    variant.sourceSets.last().assets.srcDir(assetGenDir)

    // generate assets task, this should depend on all tasks we create locally
    def assetGenTask = project.tasks.getByName("generate${variant.name.capitalize()}Assets")

    // languages json
    def languagesJsonFile = new File(assetGenDir, 'languages.json')
    def downloadLanguagesTask = project.tasks.create "download${variant.name.capitalize()}BundledLanguages", Download, {
        mustRunAfter clean

        src "${mobileContentApi}languages"
        dest languagesJsonFile
        quiet true

        doLast {
            simplifyBundledLanguages(languagesJsonFile)
        }
    }
    assetGenTask.dependsOn(downloadLanguagesTask)

    // tools json
    def toolsJsonFile = new File(assetGenDir, 'tools.json')
    def downloadToolsTask = project.tasks.create "download${variant.name.capitalize()}BundledTools", Download, {
        mustRunAfter clean

        src "${mobileContentApi}resources?filter[system]=GodTools&include=attachments,latest-translations.language"
        dest toolsJsonFile
        quiet true

        doLast {
            simplifyBundledTools(toolsJsonFile)
        }
    }
    assetGenTask.dependsOn(downloadToolsTask)

    // download attachments
    def attachmentsDir = new File(assetGenDir, 'attachments')
    def downloadAttachmentsTask = project.tasks.create("download${variant.name.capitalize()}BundledAttachments") {
        mustRunAfter clean
        dependsOn downloadToolsTask

        doLast {
            def toolsJson = new JsonSlurper().parseText(toolsJsonFile.text)
            toolsJson.data.findAll { bundledContent.tools.contains(it.attributes.abbreviation) }.each { tool ->
                bundledContent.attachments.each { attr ->
                    def attachmentId = tool.attributes.get(attr)
                    def attachment = toolsJson.included.find { it.id == attachmentId && it.type == "attachment" }
                    if (!attachment) {
                        return
                    }

                    def rawName = attachment.attributes.get('file-file-name')
                    def fileName = attachment.attributes.sha256 + rawName.substring(rawName.lastIndexOf('.'))
                    download {
                        src "${mobileContentApi}attachments/${attachmentId}/download"
                        dest new File(attachmentsDir, fileName)
                        overwrite false
                        tempAndMove true
                        quiet true
                    }
                }
            }
        }
    }
    assetGenTask.dependsOn(downloadAttachmentsTask)

    // download translations
    if (bundledContent.downloadTranslations) {
        def translationsDir = new File(assetGenDir, 'translations')
        def downloadTranslationsTask = project.tasks.create("download${variant.name.capitalize()}BundledTranslations") {
            mustRunAfter clean
            dependsOn downloadToolsTask

            doLast {
                def toolsJson = new JsonSlurper().parseText(toolsJsonFile.text)
                def tools = toolsJson.data.findAll {
                    bundledContent.tools.contains(it.attributes.abbreviation)
                }.collect { it.id }
                def languages = toolsJson.included.findAll {
                    it.type == 'language' && bundledContent.languages.contains(it.attributes.code)
                }.collect { it.id }
                def translations = toolsJson.included.findAll {
                    it.type == 'translation' && tools.contains(it.relationships.resource.data.id) && languages.contains(it.relationships.language.data.id)
                }.collect { it.id }

                translations.each { translationId ->
                    download {
                        src "${mobileContentApi}translations/${translationId}"
                        dest new File(translationsDir, "${translationId}.zip")
                        overwrite false
                        tempAndMove true
                        quiet true
                    }
                }
            }
        }
        assetGenTask.dependsOn(downloadTranslationsTask)
    }
}

static def simplifyBundledLanguages(File file) {
    def data = new JsonSlurper().parseText(file.text)

    data.data.each { language ->
        removeJsonApiAttrs(language, 'direction')
        language.remove('relationships')
    }

    sortJsonApiObject(data)
    file.text = JsonOutput.toJson(data)
}

static def simplifyBundledTools(File file) {
    def data = new JsonSlurper().parseText(file.text)

    // update main objects
    data.data.each { tool ->
        removeJsonApiAttrs(tool,
                // attributes
                'manifest', 'onesky-project-id',
                // relationships
                'system', 'translations', 'latest-drafts-translations', 'pages', 'custom-manifests', 'tips')
    }

    // update included objects
    data.included.each { obj ->
        switch (obj.type) {
            case "attachment":
                removeJsonApiAttrs(obj, "file", "is-zipped")
                break
            case "language":
                obj.remove('relationships')
                removeJsonApiAttrs(obj, 'direction')
                break
        }
    }

    sortJsonApiObject(data)
    file.text = JsonOutput.toJson(data)
}

static def removeJsonApiAttrs(obj, String... attrs) {
    attrs.each {
        obj.attributes?.remove(it)
        obj.relationships?.remove(it)
    }
}

static def sortJsonApiObject(obj) {
    sortJsonApiObjects(obj.data)
    sortJsonApiObjects(obj.included)
}

static def sortJsonApiObjects(objs) {
    objs?.sort { it.id as Integer }
    objs?.sort { it.type }
    objs?.each {
        it.relationships?.each { k, v ->
            if (v.data instanceof List) {
                v.data.sort { it.id as Integer }
            }
        }
    }
}
